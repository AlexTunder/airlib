{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Sock",
				"Socket.cpp\t(Socket.hpp)"
			],
			[
				"set",
				"setContent\tvoid setContent(const char *content)"
			],
			[
				"HTTP",
				"HTTP_LIB\tabc"
			],
			[
				"Req",
				"HttpRequestType\tHttpRequestType"
			],
			[
				"strtok",
				"strtokres\tabc"
			],
			[
				"XL",
				"Xlib.h"
			],
			[
				"gl",
				"GL/"
			],
			[
				"re",
				"red"
			],
			[
				"va",
				"values"
			],
			[
				"fie",
				"fields"
			],
			[
				"fi",
				"field"
			]
		]
	},
	"buffers":
	[
		{
			"file": "protocols/http.hpp",
			"settings":
			{
				"buffer_size": 2222,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "Socket.hpp",
			"settings":
			{
				"buffer_size": 5849,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#pragma once\n\n#ifndef HTTP_LIB\n#include <./http.hpp>\n#endif\n\nHttpRequest configureAnswer(const char *file, char *errpath, char *root){\n    HttpRequest sub;\n    char *fn = new char[4096];\n    strcpy(fn, root);\n    strcat(fn, file);\n    FILE *target = fopen(fn, \"r\");\n    if(target == NULL){\n        sub.setType((HttpRequestType)404);\n        char errorpath[64] = \"\";\n        strcpy(errorpath, errpath);\n        strcat(errorpath, \"/404.html\");\n        target = fopen(errorpath, \"r\");\n        if(target == NULL){\n            fclose(target);\n            throw HTTP_404_EX(HTTP_500_FN);\n        }\n        else{\n            char __fread_404[HTTP_ERR_SZ];\n            fread(__fread_404, 1, HTTP_ERR_SZ, target);\n            sub.setContent(__fread_404);\n            sub.setType(HttpRequestType::E404);\n            fclose(target);\n            return sub;\n        }\n    }else{\n        sub.setType(HttpRequestType::ALLOK);\n        char __fread[HTTP_BITRATE];\n        fread(__fread, 1, HTTP_BITRATE, target);\n        sub.setContent(__fread);\n        fclose(target);\n        return sub;\n    }\n}\nHttpRequest configureRequest(const char *file, HttpRequestType type){\n    HttpRequest sub;\n    sub.setType(type);\n    sub.setValue(\"$target\", (char*)file);\n    return sub;\n}\n\nchar *HttpRequest::getValue(const char *value){\n    for(int i = 0; this->fields[i] != NULL ; i++){\n        if(!strcmp(value, this->fields[i]))\n            return this->value[i];\n    }\n    return NULL;\n}\nchar *HttpRequest::getContent(){\n    return this->content;\n}\nvoid HttpRequest::setContent(const char *content){\n    this->content = new char[strlen(content)+1];\n    strcpy(this->content, content);\n}\nvoid HttpRequest::setType(HttpRequestType type){\n    this->method = new char[64];\n    if(type == HttpRequestType::GET){\n        strcpy(this->method, \"GET $target HTTP/1.1\");\n    }else if(type == HttpRequestType::POST){\n        strcpy(this->method, \"POST $target HTTP/1.1\");\n    }else if(type == HttpRequestType::HEAD){\n        strcpy(this->method, \"HEAD $target HTTP/1.1\");\n    }else if(type == HttpRequestType::CONNECT){\n        strcpy(this->method, \"CONNECT $target HTTP/1.1\");\n    }else{\n        sprintf(this->method, \"HTTP/1.1 %i\", (int)type);\n    }\n}\nvoid HttpRequest::setValue(const char *fieldname, const char *value){\n    int i = 0;\n    for(; this->fields[i] != NULL; i++);\n    this->fields[i] = new char[strlen(fieldname)];\n    this->value[i] = new char[strlen(value)];\n    strcpy(fields[i], fieldname);\n    strcpy(this->value[i], value);\n}\nHttpRequestType HttpRequest::getType(){\n    HttpRequestType rt;\n    char *firstWordOfMethod, *tmp = new char[strlen(this->method)];\n    strcpy(tmp, this->method);\n    firstWordOfMethod = strtok(this->method, \" \");\n    if(!strcmp(firstWordOfMethod, \"GET\"))\n        rt = HttpRequestType::GET;\n    else if(!strcmp(firstWordOfMethod, \"POST\"))\n        rt = HttpRequestType::POST;\n    else if(!strcmp(firstWordOfMethod, \"HEAD\"))\n        rt = HttpRequestType::HEAD;\n    else if(!strcmp(firstWordOfMethod, \"CONNECT\"))\n        rt = HttpRequestType::CONNECT;\n    else{\n        firstWordOfMethod = strtok(NULL, \" \");\n        rt = (HttpRequestType)atoi(firstWordOfMethod);\n    }\n    strcpy(this->method, tmp);\n    // strcpy()\n    return rt;\n}\nvoid HttpRequest::operator=(HttpRequest req){\n    this->method = new char[strlen(req.method)+1];\n    strcpy(this->method, req.method);\n    if(req.fields != NULL && *req.fields != NULL){\n        for(int i = 0; req.fields[i] != NULL; i++){\n            this->fields[i] = new char(strlen(req.fields[i]));\n            this->value[i] = new char(strlen(req.value[i]));\n            strcpy(this->fields[i], req.fields[i]);\n            strcpy(this->value[i], req.value[i]);\n        }\n    }\n    this->content = new char[strlen(req.content)+1];\n    strcpy(this->content, req.content);\n}\nHttpRequest::HttpRequest(){\n    this->fields = new char *;\n    this->value = new char *;\n}\nchar *HttpRequest::flush(char *to){\n    char *__sub;\n    if(to == NULL)\n        __sub= new char[HTTP_BITRATE];\n    else\n        __sub = to;\n    sprintf(__sub, \"%s\", this->method);\n    for(int i = 0; this->fields[i] != NULL; i++)\n        sprintf(__sub, \"%s\\n%s: %s\", __sub, this->fields[i], this->value[i]);\n    sprintf(__sub, \"%s\\n\\n%s\", __sub, this->content);\n    return __sub;\n}\nvoid HttpRequest::fill(char *src){\n    /***\n    pseudo:\n        first = getFirstLine(src);\n        type = getTypeByDescription(src[0]) //get/post/other\n        target = src[1]\n\n    */\n}\nHttpRequest configureRequest(const char *file, HttpRequestType rt, char *additional = NULL){\n    HttpRequest sub;\n    char *frst = new char[64];\n    if(rt == HttpRequestType::GET)\n        sprintf(frst, \"GET %s HTTP/1.1\\n\", file);\n    else if(rt == HttpRequestType::POST){\n        sprintf(frst, \"POST %s HTTP/1.1\\n\", file);\n        if(additional != NULL)\n            sub.setContent(additional);\n        else\n            throw \n    }\n    else if(rt == HttpRequest::HEAD)\n        sprintf(frst, \"HEAD %s HTTP/1.1\\n\", file);\n    else throw HTTP_IUK_EX;\n}",
			"file": "protocols/http.cpp",
			"file_size": 4924,
			"file_write_time": 132422443968821099,
			"settings":
			{
				"buffer_size": 5022,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "protocols/test.cpp",
			"settings":
			{
				"buffer_size": 839,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/C++/C++ Single File.sublime-build",
					""
				],
				[
					"Packages/C++/C++ Single File.sublime-build",
					"Run"
				]
			],
			[
				"Packages/C++/C++ Single File.sublime-build",
				"Run"
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"pa",
				"Package Control: Install Package"
			],
			[
				"Package Control: ",
				"Package Control: Disable Package"
			],
			[
				"pack",
				"Package Control: Install Package"
			],
			[
				"menu",
				"View: Toggle Menu"
			],
			[
				"manu",
				"SublimeLinter: Reload SublimeLinter and its Plugins"
			],
			[
				"",
				":$ - EOF"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"clang",
				"Package Control: Enable Package"
			],
			[
				"build",
				"Build With: C++ Single File"
			],
			[
				"package insta",
				"Package Control: Install Package"
			],
			[
				"gecontrol",
				"Package Control: List Packages"
			],
			[
				"packa",
				"Install Package Control"
			],
			[
				"c++",
				"Set Syntax: C++"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 137.0,
		"history":
		[
			"view.run_command(\"sublime_plugin.TextCommand\")",
			"view.run_command(\"my-cpp\")",
			"view.run_command(\"my-cpp.py\")",
			"view.runCommand(\"my-cpp.py\")",
			"os.system(\"vim \\\"~/.oonfig/sublime-text-3/Packages/All Autocomplete/All Autocomplate.sublime-settings\\\"\")",
			"import os",
			"os.system(\"bash\")",
			"os.system(\"clear\")",
			"import os",
			"os.system(\"clear\")",
			"clear"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/alexthunder/hentai",
		"/home/alexthunder/hentai/globus",
		"/home/alexthunder/hentai/globus/OpenCppNet",
		"/home/alexthunder/hentai/globus/OpenCppNet/protocols"
	],
	"file_history":
	[
		"/home/alexthunder/.config/sublime-text-3/Packages/User/ClangAutoComplete.sublime-settings",
		"/home/alexthunder/.config/sublime-text-3/Packages/ClangAutoComplete/ClangAutoComplete.sublime-settings",
		"/home/alexthunder/.config/sublime-text-3/Packages/User/SublimeLinter.sublime-settings",
		"/home/alexthunder/.config/sublime-text-3/Packages/SublimeLinter/SublimeLinter.sublime-settings",
		"/home/alexthunder/.config/sublime-text-3/Packages/All Autocomplete/All Autocomplete.sublime-settings",
		"/home/alexthunder/.config/sublime-text-3/Packages/Package Control/Package Control.sublime-settings",
		"/home/alexthunder/hentai/GLOBUS/tests/vertex-parser.cpp",
		"/home/alexthunder/hentai/globus/OpenCppNet/protocols/file-transfer.server.cpp",
		"/home/alexthunder/hentai/GLOBUS/tests/XWIN.example.cpp",
		"/home/alexthunder/hentai/small projects/place.cpp",
		"/home/alexthunder/hentai/small projects/calc.cpp",
		"/home/alexthunder/hentai/GLOBUS/tests/main.cpp",
		"/home/alexthunder/hentai/GLOBUS/grafic/basic.hpp",
		"/home/alexthunder/hentai/GLOBUS/grafic/window.hpp",
		"/home/alexthunder/hentai/GLOBUS/grafic/basic.cpp",
		"/home/alexthunder/hentai/GLOBUS/grafic/window.cpp",
		"/home/alexthunder/hentai/GLOBUS/grafic/event.hpp",
		"/home/alexthunder/hentai/IDE@/main.cpp",
		"/home/alexthunder/hentai/IDE@/types.cpp",
		"/home/alexthunder/hentai/IDE@/settings.cpp",
		"/home/alexthunder/hentai/IDE@/tabs-and-workspace.cpp",
		"/home/alexthunder/hentai/IDE@/menubar.cpp",
		"/home/alexthunder/hentai/IDE@/window.cpp",
		"/home/alexthunder/hentai/IDE@/explorer.cpp",
		"/home/alexthunder/hentai/idieas",
		"/home/alexthunder/hentai/sockets/globus/simple-sockets/test.cpp",
		"/home/alexthunder/hentai/sockets/globus/simple-sockets/Protocol.cpp",
		"/home/alexthunder/hentai/sockets/globus/simple-sockets/Protocols.hpp"
	],
	"find":
	{
		"height": 22.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "protocols/http.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2222,
						"regions":
						{
						},
						"selection":
						[
							[
								586,
								586
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "Socket.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5849,
						"regions":
						{
						},
						"selection":
						[
							[
								34,
								34
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				}
			]
		},
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 2,
					"file": "protocols/http.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5022,
						"regions":
						{
						},
						"selection":
						[
							[
								4898,
								4898
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1443.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "protocols/test.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 839,
						"regions":
						{
						},
						"selection":
						[
							[
								839,
								839
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 22.0
	},
	"input":
	{
		"height": 37.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.5,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.SublimeLinter":
	{
		"height": 0.0
	},
	"output.exec":
	{
		"height": 109.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.mdpopups":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "Sockets.sublime-project",
	"replace":
	{
		"height": 40.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 32.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 592.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 202.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
